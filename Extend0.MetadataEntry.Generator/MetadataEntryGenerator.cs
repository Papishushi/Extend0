using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Extend0.MetadataEntry.Generator
{
    /// <summary>
    /// Roslyn incremental generator that discovers <c>[GenerateMetadataEntry]</c> assembly
    /// attributes and emits fixed-size metadata entry structs plus a typed <c>MetadataCell</c> wrapper.
    /// </summary>
    [Generator]
    public sealed class MetadataEntryGenerator : IIncrementalGenerator
    {
        /// <summary>
        /// Fully-qualified metadata name of the <c>GenerateMetadataEntryAttribute</c> used
        /// to drive this generator.
        /// </summary>
        private const string AttrFullName = "Extend0.Metadata.CodeGen.GenerateMetadataEntryAttribute";

        /// <summary>
        /// Configures the incremental source generation pipeline:
        /// injects the attribute definition, collects all attribute usages, and
        /// produces the enum, entry structs and <c>MetadataCell</c> wrapper.
        /// </summary>
        /// <param name="context">Incremental generator initialization context supplied by Roslyn.</param>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Inyecta el atributo si no existe
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("GenerateMetadataEntryAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
            });

            // Captura [assembly: GenerateMetadataEntry(key,value)]
            var attrPairs = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => node is AttributeSyntax,
                    transform: static (ctx, _) =>
                    {
                        var attr = (AttributeSyntax)ctx.Node;

                        var sym = ctx.SemanticModel.GetSymbolInfo(attr).Symbol as IMethodSymbol; // ctor
                        if (sym?.ContainingType?.ToDisplayString() != AttrFullName) return ((int key, int val)?)null;

                        var args = attr.ArgumentList?.Arguments;
                        if (args is null || args.Value.Count < 2) return null;

                        var keyConst = ctx.SemanticModel.GetConstantValue(args.Value[0].Expression);
                        var valConst = ctx.SemanticModel.GetConstantValue(args.Value[1].Expression);
                        if (!keyConst.HasValue || !valConst.HasValue) return null;

                        return ((int)keyConst.Value!, (int)valConst.Value!);
                    })
                .Where(static x => x.HasValue)
                .Select(static (x, _) => x!.Value)
                .Collect();

            context.RegisterSourceOutput(attrPairs, (spc, entries) =>
            {
                var uniq = entries.Distinct().OrderBy(x => x.key).ThenBy(x => x.val).ToArray();
                if (uniq.Length == 0) return;

                // 0) Enum + extensiones basados en las variantes detectadas
                var enumAndExt = EmitEnumAndExtensions(uniq);
                spc.AddSource("MetadataEntrySize.g.cs", SourceText.From(enumAndExt, Encoding.UTF8));

                // 1) Emitir cada struct MetadataEntry{K}x{V}
                foreach (var (key, value) in uniq)
                {
                    var code = EmitVariant(key, value);
                    spc.AddSource($"MetadataEntry_{key}x{value}.g.cs", SourceText.From(code, Encoding.UTF8));
                }

                // 2) Emitir MetadataCell con switch solo para las variantes generadas
                var cell = EmitMetadataCell(uniq);
                spc.AddSource("MetadataCell.g.cs", SourceText.From(cell, Encoding.UTF8));
            });
        }

        /// <summary>
        /// Generates the source code for a single fixed-size
        /// <c>MetadataEntry&lt;key x value&gt;</c> struct variant.
        /// </summary>
        /// <param name="key">Maximum UTF-8 byte capacity of the key segment.</param>
        /// <param name="val">Maximum UTF-8 byte capacity of the value segment.</param>
        /// <returns>C# source for the concrete <c>IMetadataEntry</c> implementation.</returns>
        private static string EmitVariant(int key, int val)
        {
            var name = $"MetadataEntry{key}x{val}";
            return $@"// <auto-generated/>
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Extend0.Metadata.CodeGen
{{
    /// <summary>
    /// A fixed-size metadata entry storing a UTF-8 key/value pair inline in unmanaged memory.
    /// </summary>
    [SkipLocalsInit]
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = KEY_SIZE + VALUE_SIZE)]
    public unsafe struct {name} : IMetadataEntry
    {{
        public const int KEY_SIZE = {key};
        public const int VALUE_SIZE = {val};

        public static int KeyCapacity   => KEY_SIZE;
        public static int ValueCapacity => VALUE_SIZE;

        public fixed byte Key[KEY_SIZE];
        public fixed byte Value[VALUE_SIZE];

        public {name}()
        {{
            Unsafe.InitBlock(ref Key[0], 0, KEY_SIZE);
            Unsafe.InitBlock(ref Value[0], 0, VALUE_SIZE);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TrySetKey(ReadOnlySpan<byte> keyUtf8)
        {{
            if (keyUtf8.Length >= KEY_SIZE) return false;
            fixed (byte* pKey = Key)
            {{
                var dst = new Span<byte>(pKey, KEY_SIZE);
                dst.Clear();
                keyUtf8.CopyTo(dst);
                return true;
            }}
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TrySetValue(ReadOnlySpan<byte> valueUtf8)
        {{
            if (valueUtf8.Length >= VALUE_SIZE) return false;
            fixed (byte* pVal = Value)
            {{
                var dst = new Span<byte>(pVal, VALUE_SIZE);
                dst.Clear();
                valueUtf8.CopyTo(dst);
                return true;
            }}
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool KeyEquals(void* entry, ReadOnlySpan<byte> keyUtf8)
        {{
            if (keyUtf8.Length >= KEY_SIZE) return false;
            byte* pKey = (byte*)entry;
            var stored = new ReadOnlySpan<byte>(pKey, KEY_SIZE);

            int storedLen = stored.IndexOf((byte)0);
            if (storedLen < 0) storedLen = KEY_SIZE;

            return storedLen == keyUtf8.Length
                && stored[..storedLen].SequenceEqual(keyUtf8);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TrySetKey(string key)
        {{
            int n = Encoding.UTF8.GetByteCount(key);
            if (n >= KEY_SIZE) return false;
            Span<byte> tmp = n <= 256 ? stackalloc byte[n] : new byte[n];
            Encoding.UTF8.GetBytes(key, tmp);
            return TrySetKey(tmp);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TrySetValue(string str)
        {{
            int n = Encoding.UTF8.GetByteCount(str);
            if (n >= VALUE_SIZE) return false;
            Span<byte> tmp = n <= 512 ? stackalloc byte[n] : new byte[n];
            Encoding.UTF8.GetBytes(str, tmp);
            return TrySetValue(tmp);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool KeyEquals(void* entry, string key)
        {{
            int n = Encoding.UTF8.GetByteCount(key);
            if (n >= KEY_SIZE) return false;
            Span<byte> tmp = n <= 256 ? stackalloc byte[n] : new byte[n];
            Encoding.UTF8.GetBytes(key, tmp);
            return KeyEquals(entry, (ReadOnlySpan<byte>)tmp);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* GetValuePointer(void* entry)
            => (byte*)entry + KEY_SIZE;
    }}
}}
";
        }

        /// <summary>
        /// Generates the source code for a single fixed-size
        /// <c>MetadataEntry&lt;key x value&gt;</c> struct variant.
        /// </summary>
        /// <param name="key">Maximum UTF-8 byte capacity of the key segment.</param>
        /// <param name="val">Maximum UTF-8 byte capacity of the value segment.</param>
        /// <returns>C# source for the concrete <c>IMetadataEntry</c> implementation.</returns>
        private static string EmitMetadataCell((int key, int val)[] uniq)
        {
            // Genera los 'arms' del switch en el ctor de MetadataCell
            var arms = new StringBuilder();
            foreach (var (k, v) in uniq)
            {
                arms.AppendLine($"                MetadataEntrySize.Entry{k}x{v} => NativeMemory.AllocZeroed(1, (nuint)sizeof(MetadataEntry{k}x{v})),");
            }

            return $@"// <auto-generated/>
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

#nullable enable

namespace Extend0.Metadata.CodeGen
{{
    public readonly unsafe partial struct MetadataCell : IDisposable
    {{
        private readonly MetadataEntrySize _size;
        private readonly void* _entry;
        private readonly bool _owns;

        private static int KeyCap(MetadataEntrySize s) => s.GetKeySize();
        private static int ValueCap(MetadataEntrySize s) => s.GetValueSize();
        private static byte* ValuePtr(void* entry, MetadataEntrySize s) => (byte*)entry + KeyCap(s);

        private MetadataCell(MetadataEntrySize size, void* ptr, bool owns)
        {{
            _size = size; _entry = ptr; _owns = owns;
        }}

        public MetadataCell(MetadataEntrySize size)
        {{
            _size = size;
            _owns = true;
            _entry = size switch
            {{
{arms.ToString().TrimEnd()}
                _ => throw new ArgumentOutOfRangeException(nameof(size), size, ""Unsupported MetadataEntrySize""),
            }};
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TrySetKey(ReadOnlySpan<byte> keyUtf8)
        {{
            int cap = KeyCap(_size);
            if (keyUtf8.Length >= cap) return false;
            var dst = new Span<byte>(_entry, cap);
            dst.Clear();
            keyUtf8.CopyTo(dst);
            return true;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TrySetValue(ReadOnlySpan<byte> valueUtf8)
        {{
            int cap = ValueCap(_size);
            if (valueUtf8.Length >= cap) return false;
            var dst = new Span<byte>(ValuePtr(_entry, _size), cap);
            dst.Clear();
            valueUtf8.CopyTo(dst);
            return true;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TrySetKey(string key)
        {{
            int n = Encoding.UTF8.GetByteCount(key);
            if (n >= KeyCap(_size)) return false;
            Span<byte> tmp = n <= 256 ? stackalloc byte[n] : new byte[n];
            Encoding.UTF8.GetBytes(key, tmp);
            return TrySetKey(tmp);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TrySetValue(string value)
        {{
            int n = Encoding.UTF8.GetByteCount(value);
            if (n >= ValueCap(_size)) return false;
            Span<byte> tmp = n <= 512 ? stackalloc byte[n] : new byte[n];
            Encoding.UTF8.GetBytes(value, tmp);
            return TrySetValue(tmp);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetKey(out ReadOnlySpan<byte> keyUtf8)
        {{
            int cap = KeyCap(_size);
            var stored = new ReadOnlySpan<byte>(_entry, cap);
            int len = stored.IndexOf((byte)0);
            if (len == 0) {{ keyUtf8 = default; return false; }}
            keyUtf8 = len < 0 ? stored : stored[..len];
            return true;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetKey(out string? key)
        {{
            if (TryGetKey(out ReadOnlySpan<byte> k))
            {{
                key = Encoding.UTF8.GetString(k);
                return true;
            }}
            key = null;
            return false;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetValue(ReadOnlySpan<byte> keyUtf8, out ReadOnlySpan<byte> valueUtf8)
        {{
            if (!KeyEquals(keyUtf8))
            {{
                valueUtf8 = default;
                return false;
            }}
            int cap = ValueCap(_size);
            var stored = new ReadOnlySpan<byte>(ValuePtr(_entry, _size), cap);
            int len = stored.IndexOf((byte)0);
            valueUtf8 = len < 0 ? stored : stored[..len];
            return true;
        }}

        public bool TryGetValue(string key, out string? value)
        {{
            int n = Encoding.UTF8.GetByteCount(key);
            Span<byte> tmp = n <= 256 ? stackalloc byte[n] : new byte[n];
            Encoding.UTF8.GetBytes(key, tmp);
            if (TryGetValue(tmp, out var v))
            {{
                value = Encoding.UTF8.GetString(v);
                return true;
            }}
            value = null;
            return false;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool KeyEquals(ReadOnlySpan<byte> keyUtf8)
        {{
            int cap = KeyCap(_size);
            if (keyUtf8.Length >= cap) return false;
            var stored = new ReadOnlySpan<byte>(_entry, cap);
            int len = stored.IndexOf((byte)0);
            if (len < 0) len = cap;
            return len == keyUtf8.Length && stored[..len].SequenceEqual(keyUtf8);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte* GetValuePointer() => ValuePtr(_entry, _size);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static MetadataCell FromPointer(MetadataEntrySize size, void* ptr, bool owns) => new(size, ptr, owns);

        public int KeySize => KeyCap(_size);
        public int ValueSize => ValueCap(_size);

        public void Dispose()
        {{
            if (_owns && _entry != null)
            {{
                NativeMemory.Free(_entry);
            }}
        }}
    }}
}}
";
        }

        /// <summary>
        /// Embedded source for the <c>[GenerateMetadataEntry]</c> attribute that consumers
        /// apply at the assembly level to declare supported key/value size pairs.
        /// </summary>
        private const string AttributeSource = @"// <auto-generated/>
using System;

namespace Extend0.Metadata.CodeGen
{
    /// <summary>
    /// Declara una variante de struct MetadataEntry con tamaño fijo, p.ej. [assembly: GenerateMetadataEntry(64,256)].
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
    internal sealed class GenerateMetadataEntryAttribute : Attribute
    {
        public int KeySize { get; }
        public int ValueSize { get; }

        public GenerateMetadataEntryAttribute(int keySize, int valueSize)
        {
            if (keySize <= 0) throw new ArgumentOutOfRangeException(nameof(keySize));
            if (valueSize <= 0) throw new ArgumentOutOfRangeException(nameof(valueSize));
            KeySize = keySize;
            ValueSize = valueSize;
        }
    }
}
";

        /// <summary>
        /// Generates the <c>MetadataEntrySize</c> enum and its extension methods
        /// based on the discovered (keySize, valueSize) combinations.
        /// </summary>
        /// <param name="uniq">
        /// Set of unique (keySize, valueSize) pairs collected from attribute usages.
        /// </param>
        /// <returns>
        /// C# source that defines the enum plus helpers to pack/unpack and validate sizes.
        /// </returns>
        private static string EmitEnumAndExtensions((int key, int val)[] uniq)
        {
            var sbEnum = new StringBuilder();
            sbEnum.AppendLine(@"// <auto-generated/>
using System;
using System.Linq;

namespace Extend0.Metadata.CodeGen
{
    /// <summary>
    /// Variantes de MetadataEntry. El valor se codifica como (KeySize << 16) | ValueSize.
    /// </summary>
    public enum MetadataEntrySize : int
    {");

            foreach (var (k, v) in uniq)
                sbEnum.AppendLine($"        Entry{k}x{v} = 0x{(k << 16 | v):X8},");

            sbEnum.AppendLine(@"    }");

            // Tabla de válidos (int packed) ya ordenada
            var packed = uniq.Select(p => (p.key << 16) | p.val).OrderBy(x => x).ToArray();
            var packedLiterals = string.Join(", ", packed.Select(x => $"0x{x:X8}"));

            var sbExt = new StringBuilder();
            sbExt.AppendLine($@"// <auto-generated/>

    public static class MetadataEntrySizeExtensions
    {{
        // Array ordenado de variantes válidas (packed = (key<<16)|value)
        private static readonly int[] ValidPacked = new int[] {{ {packedLiterals} }};

        /// <summary>Devuelve (KeySize, ValueSize) des-empaquetados del enum.</summary>
        public static (int KeySize, int ValueSize) Decompose(this MetadataEntrySize kind)
            => (((int)kind >> 16) & 0xFFFF, (int)kind & 0xFFFF);

        public static int GetKeySize(this MetadataEntrySize kind) => ((int)kind >> 16) & 0xFFFF;
        public static int GetValueSize(this MetadataEntrySize kind) => (int)kind        & 0xFFFF;

        /// <summary>Nombre canónico del struct generado.</summary>
        public static string GetGeneratedTypeName(this MetadataEntrySize kind)
        {{
            var (k, v) = kind.Decompose();
            return $""Extend0.Metadata.CodeGen.MetadataEntry{{k}}x{{v}}"";
        }}

        /// <summary>Empaqueta a int: (key &lt;&lt; 16) | value (SIN validar).</summary>
        public static int ToPacked(this MetadataEntrySize kind) => (int)kind;

        // ---------------- PACK/UNPACK helpers ----------------

        /// <summary>Convierte (keySize, valueSize) a enum usando bit ops (SIN validar).</summary>
        public static MetadataEntrySize PackUnchecked(int keySize, int valueSize)
            => (MetadataEntrySize)(((keySize & 0xFFFF) << 16) | (valueSize & 0xFFFF));

        /// <summary>Intenta convertir (keySize, valueSize) a enum SOLO si es variante soportada.</summary>
        public static bool TryPack(int keySize, int valueSize, out MetadataEntrySize kind)
        {{
            int packed = ((keySize & 0xFFFF) << 16) | (valueSize & 0xFFFF);
            bool ok = Array.BinarySearch(ValidPacked, packed) >= 0;
            kind = ok ? (MetadataEntrySize)packed : default;
            return ok;
        }}

        /// <summary>Convierte el int empaquetado al enum (SIN validar).</summary>
        public static MetadataEntrySize FromPackedUnchecked(int packed)
            => (MetadataEntrySize)packed;

        /// <summary>Intenta convertir el int empaquetado al enum SOLO si es variante soportada.</summary>
        public static bool TryFromPacked(int packed, out MetadataEntrySize kind)
        {{
            bool ok = Array.BinarySearch(ValidPacked, packed) >= 0;
            kind = ok ? (MetadataEntrySize)packed : default;
            return ok;
        }}

        /// <summary>¿Está soportado (keySize, valueSize)?</summary>
        public static bool IsSupported(int keySize, int valueSize)
        {{
            int packed = ((keySize & 0xFFFF) << 16) | (valueSize & 0xFFFF);
            return Array.BinarySearch(ValidPacked, packed) >= 0;
        }}
    }}
}}");

            return sbEnum.ToString() + '\n' + sbExt.ToString();
        }
    }
}